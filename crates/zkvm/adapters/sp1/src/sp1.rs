use anyhow::{Context, Ok, Result};
use express_zkvm::{
    AggregationInput, Proof, ProverOptions, VerificationKey, ZKVMHost, ZKVMInputBuilder,
    ZKVMVerifier,
};
use serde::{de::DeserializeOwned, Serialize};
use serde_json::to_vec;
use snark_bn254_verifier::Groth16Verifier;
use sp1_sdk::{
    HashableKey, ProverClient, SP1Proof, SP1ProofWithPublicValues, SP1Stdin, SP1VerifyingKey,
};
use substrate_bn::Fr;

// A wrapper around SP1Stdin
pub struct SP1ProofInputBuilder(SP1Stdin);

impl<'a> ZKVMInputBuilder<'a> for SP1ProofInputBuilder {
    type Input = SP1Stdin;
    fn new() -> SP1ProofInputBuilder {
        SP1ProofInputBuilder(SP1Stdin::new())
    }

    fn write<T: serde::Serialize>(&mut self, item: &T) -> anyhow::Result<&mut Self> {
        self.0.write(item);
        Ok(self)
    }

    fn write_borsh<T: borsh::BorshSerialize>(&mut self, item: &T) -> anyhow::Result<&mut Self> {
        let slice = borsh::to_vec(item)?;
        self.write_serialized(&slice)
    }

    fn write_serialized(&mut self, item: &[u8]) -> anyhow::Result<&mut Self> {
        let len = item.len() as u32;
        self.0.write(&len);
        self.0.write_slice(item);
        Ok(self)
    }

    fn write_proof(&mut self, item: AggregationInput) -> anyhow::Result<&mut Self> {
        let proof: SP1ProofWithPublicValues = bincode::deserialize(item.proof().as_bytes())?;
        let vkey: SP1VerifyingKey = bincode::deserialize(item.vk().as_bytes())?;

        // Write the verification key and the public values of the program that'll be proven
        // inside zkVM.
        // Note: The vkey is written here so we don't have to hardcode it in guest code.
        // TODO: This should be fixed once the guest code is finalized
        self.0.write(&vkey.hash_u32());
        self.0.write(&proof.public_values);

        // Write the proofs.
        //
        // Note: this data will not actually be read by the aggregation program, instead it will
        // be witnessed by the prover during the recursive aggregation process
        // inside SP1 itself.
        match proof.proof {
            SP1Proof::Compressed(compressed_proof) => {
                self.0.write_proof(compressed_proof, vkey.vk);
            }
            _ => return Err(anyhow::anyhow!("can only handle compressed proofs")),
        }

        Ok(self)
    }

    fn build(&mut self) -> anyhow::Result<Self::Input> {
        anyhow::Ok(self.0.clone())
    }
}

/// A host for the `SP1` zkVM that stores the guest program in ELF format.
/// The `SP1Host` is responsible for program execution and proving
#[derive(Clone)]
pub struct SP1Host {
    elf: Vec<u8>,
    prover_options: ProverOptions,
}

impl ZKVMHost for SP1Host {
    type Input<'a> = SP1ProofInputBuilder;
    fn init(guest_code: Vec<u8>, prover_options: ProverOptions) -> Self {
        SP1Host {
            elf: guest_code,
            prover_options,
        }
    }

    fn prove<'a>(
        &self,
        prover_input: <Self::Input<'a> as ZKVMInputBuilder<'a>>::Input,
    ) -> anyhow::Result<(Proof, VerificationKey)> {
        // Init the prover
        if self.prover_options.use_mock_prover {
            std::env::set_var("SP1_PROVER", "mock");
        }
        let client = ProverClient::new();
        let (pk, vk) = client.setup(&self.elf);

        // Start proving
        let mut prover = client.prove(&pk, prover_input);
        if self.prover_options.enable_compression {
            prover = prover.compressed();
        }
        if self.prover_options.stark_to_snark_conversion {
            prover = prover.groth16();
        }

        let proof = prover.run()?;

        // Proof serialization
        let serialized_proof = bincode::serialize(&proof)?;
        let verification_key = bincode::serialize(&vk)?;

        Ok((
            Proof::new(serialized_proof),
            VerificationKey(verification_key),
        ))
    }
}

/// A verifier for the `SP1` zkVM, responsible for verifying proofs generated by the host
pub struct SP1Verifier;

impl ZKVMVerifier for SP1Verifier {
    fn verify(verification_key: &VerificationKey, proof: &Proof) -> anyhow::Result<()> {
        let proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let vkey: SP1VerifyingKey = bincode::deserialize(&verification_key.0)?;

        let client = ProverClient::new();
        client.verify(&proof, &vkey)?;

        Ok(())
    }

    fn verify_with_public_params<T: DeserializeOwned + serde::Serialize>(
        verification_key: &VerificationKey,
        public_params: T,
        proof: &Proof,
    ) -> anyhow::Result<()> {
        let mut proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let vkey: SP1VerifyingKey = bincode::deserialize(&verification_key.0)?;

        let client = ProverClient::new();
        client.verify(&proof, &vkey)?;

        let actual_public_parameter: T = proof.public_values.read();

        // TODO: use custom ZKVM error
        anyhow::ensure!(
            to_vec(&actual_public_parameter)? == to_vec(&public_params)?,
            "Failed to verify proof given the public param"
        );

        Ok(())
    }

    fn extract_public_output<T: Serialize + DeserializeOwned>(proof: &Proof) -> anyhow::Result<T> {
        let mut proof: SP1ProofWithPublicValues = bincode::deserialize(proof.as_bytes())?;
        let public_params: T = proof.public_values.read();
        Ok(public_params)
    }
}

// Copied from ~/.sp1/circuits/v2.0.0/groth16_vk.bin
// This is same for all the SP1 programs that uses v2.0.0
pub const GROTH16_VK_BYTES: &[u8] = include_bytes!("groth16_vk.bin");
impl SP1Verifier {
    pub fn verify_groth16(
        proof: &[u8],
        vkey_hash: &[u8],
        committed_values_digest: &[u8],
    ) -> Result<()> {
        let vk = GROTH16_VK_BYTES;

        // Convert vkey_hash to Fr, mapping the error to anyhow::Error
        let vkey_hash_fr = Fr::from_slice(vkey_hash)
            .map_err(|e| anyhow::anyhow!(e))
            .context("Unable to convert vkey_hash to Fr")?;

        // Convert committed_values_digest to Fr, mapping the error to anyhow::Error
        let committed_values_digest_fr = Fr::from_slice(committed_values_digest)
            .map_err(|e| anyhow::anyhow!(e))
            .context("Unable to convert committed_values_digest to Fr")?;

        // Perform the Groth16 verification, mapping any error to anyhow::Error
        let verification_result =
            Groth16Verifier::verify(proof, vk, &[vkey_hash_fr, committed_values_digest_fr])
                .map_err(|e| anyhow::anyhow!(e))
                .context("Groth16 verification failed")?;

        if verification_result {
            Ok(())
        } else {
            Err(anyhow::anyhow!("Groth16 proof verification returned false"))
        }
    }
}

// NOTE: SP1 prover runs in release mode only; therefore run the tests on release mode only
#[cfg(test)]
mod tests {

    use num_bigint::BigUint;
    use num_traits::Num;
    use sp1_sdk::{MockProver, Prover};

    use super::*;

    // Adding compiled guest code `TEST_ELF` to save the build time
    // #![no_main]
    // sp1_zkvm::entrypoint!(main);
    // fn main() {
    //     let n = sp1_zkvm::io::read::<u32>();
    //     sp1_zkvm::io::commit(&n);
    // }
    const TEST_ELF: &[u8] = include_bytes!("../tests/elf/riscv32im-succinct-zkvm-elf");

    #[test]
    fn test_mock_prover() {
        if cfg!(debug_assertions) {
            panic!("SP1 prover runs in release mode only");
        }

        let input: u32 = 1;

        let mut prover_input_builder = SP1ProofInputBuilder::new();
        prover_input_builder.write(&input).unwrap();
        let prover_input = prover_input_builder.build().unwrap();

        // assert proof generation works
        let zkvm = SP1Host::init(TEST_ELF.to_vec(), ProverOptions::default());
        let (proof, vk) = zkvm.prove(prover_input).expect("Failed to generate proof");

        // assert proof verification works
        SP1Verifier::verify(&vk, &proof).expect("Proof verification failed");

        // assert public outputs extraction from proof  works
        let out: u32 = SP1Verifier::extract_public_output(&proof).expect(
            "Failed to extract public
    outputs",
        );
        assert_eq!(input, out)
    }

    #[test]
    fn test_mock_prover_with_public_param() {
        if cfg!(debug_assertions) {
            panic!("SP1 prover runs in release mode only");
        }

        let input: u32 = 1;

        let mut prover_input_builder = SP1ProofInputBuilder::new();
        prover_input_builder.write(&input).unwrap();
        let prover_input = prover_input_builder.build().unwrap();

        // assert proof generation works
        let zkvm = SP1Host::init(TEST_ELF.to_vec(), ProverOptions::default());
        let (proof, vk) = zkvm.prove(prover_input).expect("Failed to generate proof");

        // assert proof verification works
        SP1Verifier::verify_with_public_params(&vk, input, &proof)
            .expect("Proof verification failed");
    }

    #[test]
    fn test_groth16_verification() {
        if cfg!(debug_assertions) {
            panic!("SP1 prover runs in release mode only");
        }

        sp1_sdk::utils::setup_logger();

        // let input: u32 = 1;

        // let mut prover_input = ProverInput::new();
        // prover_input.write(input);

        // // Prover Options to generate Groth16 proof
        // let prover_options = ProverOptions {
        //     enable_compression: false,
        //     use_mock_prover: false,
        //     stark_to_snark_conversion: true,
        // };
        // let zkvm = SP1Host::init(TEST_ELF.to_vec(), prover_options);

        // // assert proof generation works
        // let (proof, vk) = zkvm.prove(&prover_input).expect("Failed to generate proof");

        // let filename = "proof-groth16.bin";
        // let mut file = File::create(filename).unwrap();
        // file.write_all(proof.as_bytes()).unwrap();

        let client = MockProver::new();
        let (_, vk) = client.setup(TEST_ELF);

        let raw_groth16_proof = include_bytes!("../tests/proofs/proof-groth16.bin");
        let proof: SP1ProofWithPublicValues =
            bincode::deserialize(raw_groth16_proof).expect("Failed to deserialize Groth16 proof");

        // assert proof verification works
        client
            .verify(&proof, &vk)
            .expect("Proof verification failed");

        let committed_values_digest = &proof.public_values.hash_bn254().to_bytes_be();
        let groth16_proof_bytes = proof
            .proof
            .try_as_groth_16()
            .expect("Failed to convert proof to Groth16")
            .raw_proof;
        let groth16_proof =
            hex::decode(&groth16_proof_bytes).expect("Failed to decode Groth16 proof");

        let vkey_hash = BigUint::from_str_radix(
            vk.bytes32()
                .strip_prefix("0x")
                .expect("vkey should start with '0x'"),
            16,
        )
        .expect("Failed to parse vkey hash")
        .to_bytes_be();

        assert!(
            SP1Verifier::verify_groth16(&groth16_proof, &vkey_hash, committed_values_digest)
                .is_ok()
        );
    }
}
